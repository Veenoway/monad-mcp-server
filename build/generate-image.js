import dotenv from "dotenv";
import path from "path";
import { fileURLToPath } from "url";
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
dotenv.config({ path: path.resolve(__dirname, "../.env") });
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import axios from "axios";
import { ethers } from "ethers";
import FormData from "form-data";
import { z } from "zod";
import { NFT_FACTORY_ABI, NFT_FACTORY_ADDRESS } from "./shared/constants.js";
console.error("Starting MCP server...");
export const provider = new ethers.JsonRpcProvider("https://testnet-rpc2.monad.xyz/52227f026fa8fac9e2014c58fbf5643369b3bfc6", {
    name: "Monad Testnet",
    chainId: 10143,
});
export const server = new McpServer({
    name: "generate-image-mint-nft",
    version: "0.0.1",
    capabilities: ["image-nft-generation"],
});
server.tool("image-nft-generation", "Generate an image from a text prompt and mint it directly as an NFT", {
    prompt: z.string().describe("Description of the image to generate"),
    userAddress: z.string().describe("Wallet to send NFT"),
}, 
// @ts-ignore - Complex response type
async ({ prompt, userAddress }, _extra) => {
    try {
        console.error(`Generating image for prompt: "${prompt}"`);
        const trimmedPrompt = prompt.slice(0, 1000);
        const requestBody = {
            model: "dall-e-2",
            prompt: trimmedPrompt,
            n: 1,
            size: "1024x1024",
        };
        const response = await axios.post("https://api.openai.com/v1/images/generations", requestBody, {
            headers: {
                "Content-Type": "application/json",
                Authorization: `Bearer ${process.env.OPENAI_API_KEY}`,
            },
        });
        if (!response.data?.data?.[0]?.url) {
            throw new Error("Unexpected response from DALL-E");
        }
        const imageUrl = response.data.data[0].url;
        console.error("Downloading generated image...");
        const imageBlob = await axios.get(imageUrl, {
            responseType: "arraybuffer",
        });
        const imageBuffer = Buffer.from(imageBlob.data);
        console.error("Uploading image to IPFS via Pinata...");
        const formData = new FormData();
        formData.append("file", imageBuffer, {
            filename: "nft-image.png",
            contentType: "image/png",
        });
        formData.append("pinataMetadata", JSON.stringify({
            name: `generated-nft-${Date.now()}`,
        }));
        const pinataUpload = await axios.post("https://api.pinata.cloud/pinning/pinFileToIPFS", formData, {
            maxBodyLength: Infinity,
            headers: {
                Authorization: `Bearer ${process.env.PINATA_JWT}`,
                ...formData.getHeaders(),
            },
        });
        const imageIpfsHash = pinataUpload.data.IpfsHash;
        const ipfsImageUrl = `ipfs://${imageIpfsHash}`;
        console.error(`Image uploaded to IPFS: ${ipfsImageUrl}`);
        // Generate NFT metadata
        console.error("Creating and uploading NFT metadata...");
        const metadata = {
            name: `AI Image - ${new Date().toISOString().split("T")[0]}`,
            description: `Image generated from prompt: "${prompt}"`,
            image: ipfsImageUrl,
            attributes: [
                {
                    trait_type: "Generated by",
                    value: "VeenoX AI",
                },
                {
                    trait_type: "Date",
                    value: new Date().toISOString(),
                },
            ],
        };
        const metadataUpload = await axios.post("https://api.pinata.cloud/pinning/pinJSONToIPFS", {
            pinataContent: metadata,
            pinataMetadata: {
                name: `nft-metadata-${Date.now()}.json`,
            },
        }, {
            headers: {
                Authorization: `Bearer ${process.env.PINATA_JWT}`,
                "Content-Type": "application/json",
            },
        });
        const metadataIpfsHash = metadataUpload.data.IpfsHash;
        const tokenURI = `ipfs://${metadataIpfsHash}`;
        console.error(`Metadata uploaded: ${tokenURI}`);
        // MINT NFT
        console.error("Minting NFT on Monad Testnet...");
        const deployerWallet = new ethers.Wallet("5d5185d7a8ead54c253633730eb0c78905d0426dbf12972d3ac0359e15207a82", provider);
        const nftContract = new ethers.Contract(NFT_FACTORY_ADDRESS, NFT_FACTORY_ABI, deployerWallet);
        const mintTx = await nftContract.mint(tokenURI, userAddress, {
            gasLimit: 500_000,
        });
        await mintTx.wait();
        console.error(`NFT minted successfully: TX ${mintTx.hash}`);
        return {
            content: [
                {
                    type: "text",
                    text: `✅ Image generated and minted as NFT for **${userAddress}** !

- **Prompt**: "${prompt}"
- **IPFS Image**: [View image](https://gateway.pinata.cloud/ipfs/${imageIpfsHash})
- **Token URI**: ${tokenURI}
- **Transaction**: [View on Monad Explorer](https://testnet.monadexplorer.com/tx/${mintTx.hash})
          `,
                },
            ],
        };
    }
    catch (error) {
        console.error("Error:", JSON.stringify(error, Object.getOwnPropertyNames(error), 2));
        return {
            content: [
                {
                    type: "text",
                    text: `❌ Error during generation and minting: ${error.message || JSON.stringify(error)}`,
                },
            ],
        };
    }
});
// Start server
async function main() {
    try {
        const transport = new StdioServerTransport();
        await server.connect(transport);
        console.error("MCP Monad testnet server started on stdio");
    }
    catch (error) {
        console.error("Server initialization error:", error);
    }
}
main().catch((error) => {
    console.error("Fatal error in main():", error);
    process.exit(1);
});
